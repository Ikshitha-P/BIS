import numpy as np
import random
import math

# Directions (4-connected grid: up, down, left, right)
DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]

class ACO_RobotPath:
    def __init__(self, grid, start, goal, n_ants=20, n_iterations=100,
                 alpha=1.0, beta=3.0, evaporation=0.5, Q=100):
        self.grid = grid
        self.start = start
        self.goal = goal
        self.n_ants = n_ants
        self.n_iterations = n_iterations
        self.alpha = alpha
        self.beta = beta
        self.evaporation = evaporation
        self.Q = Q

        self.height, self.width = grid.shape

        self.pheromone = {}
        for x in range(self.width):
            for y in range(self.height):
                if grid[y, x] == 0:
                    self.pheromone[(x, y)] = {}
                    for dx, dy in DIRECTIONS:
                        nx, ny = x + dx, y + dy
                        if self.is_valid(nx, ny):
                            self.pheromone[(x, y)][(nx, ny)] = 1.0

        self.heuristic = {}
        for x in range(self.width):
            for y in range(self.height):
                if grid[y, x] == 0:
                    dist = self.euclidean_distance((x, y), goal)
                    self.heuristic[(x, y)] = 1.0 / (dist + 1e-10)

        self.best_path = None
        self.best_cost = float('inf')

    def is_valid(self, x, y):
        return 0 <= x < self.width and 0 <= y < self.height and self.grid[y, x] == 0

    def euclidean_distance(self, a, b):
        return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

    def run(self):
        for iteration in range(self.n_iterations):
            all_paths = []
            all_costs = []

            for ant in range(self.n_ants):
                path, cost = self.construct_solution()
                if path:
                    all_paths.append(path)
                    all_costs.append(cost)
                    if cost < self.best_cost:
                        self.best_cost = cost
                        self.best_path = path

            self.evaporate_pheromone()
            self.update_pheromone(all_paths, all_costs)

            if iteration % 10 == 0 or iteration == self.n_iterations-1:
                print(f"Iteration {iteration+1}/{self.n_iterations}, Best cost: {self.best_cost:.2f}")

        return self.best_path, self.best_cost

    def construct_solution(self):
        current = self.start
        path = [current]
        visited = set()
        visited.add(current)
        max_steps = self.width * self.height

        for step in range(max_steps):
            neighbors = self.get_neighbors(current, visited)
            if not neighbors:
                return None, float('inf')

            probs = self.transition_probabilities(current, neighbors)
            next_cell = self.roulette_wheel_selection(neighbors, probs)
            path.append(next_cell)
            visited.add(next_cell)
            current = next_cell

            if current == self.goal:
                cost = self.path_cost(path)
                return path, cost

        return None, float('inf')

    def get_neighbors(self, cell, visited):
        x, y = cell
        neighbors = []
        for dx, dy in DIRECTIONS:
            nx, ny = x + dx, y + dy
            if self.is_valid(nx, ny) and (nx, ny) not in visited:
                neighbors.append((nx, ny))
        return neighbors

    def transition_probabilities(self, current, neighbors):
        pheromone_values = []
        heuristic_values = []

        for nbr in neighbors:
            pheromone = self.pheromone[current].get(nbr, 0.1)
            heuristic = self.heuristic[nbr]
            pheromone_values.append(pheromone ** self.alpha)
            heuristic_values.append(heuristic ** self.beta)

        numerators = [p * h for p, h in zip(pheromone_values, heuristic_values)]
        denom = sum(numerators)
        probabilities = [num / denom if denom > 0 else 1/len(neighbors) for num in numerators]

        return probabilities

    def roulette_wheel_selection(self, choices, probabilities):
        r = random.random()
        cumulative = 0.0
        for choice, prob in zip(choices, probabilities):
            cumulative += prob
            if r <= cumulative:
                return choice
        return choices[-1]

    def path_cost(self, path):
        cost = 0.0
        for i in range(len(path) - 1):
            cost += self.euclidean_distance(path[i], path[i + 1])
        return cost

    def evaporate_pheromone(self):
        for cell, nbrs in self.pheromone.items():
            for nbr in nbrs:
                self.pheromone[cell][nbr] *= (1 - self.evaporation)
                if self.pheromone[cell][nbr] < 0.1:
                    self.pheromone[cell][nbr] = 0.1

    def update_pheromone(self, paths, costs):
        for path, cost in zip(paths, costs):
            deposit = self.Q / cost if cost > 0 else 0
            for i in range(len(path) - 1):
                current = path[i]
                nxt = path[i + 1]
                self.pheromone[current][nxt] += deposit


def main():
    grid = np.array([
        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
        [0, 1, 1, 1, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],
        [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],
        [1, 1, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 1, 0, 1, 1, 1, 0, 1, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 0]
    ])

    start = (0, 0)
    goal = (9, 9)

    aco = ACO_RobotPath(grid, start, goal, n_ants=30, n_iterations=100, alpha=1, beta=5, evaporation=0.3, Q=100)
    best_path, best_cost = aco.run()

    print("Best path cost:", best_cost)
    print("Best path:", best_path)

if __name__ == "__main__":
    main()
